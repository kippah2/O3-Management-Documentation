.. /scriptsoverview
.. /monthlyarchivecreate
.. /copytemplate
.. /moveo3notes
.. /getadusers
Userprov.ps1
============

Userprov.ps1 is the most complex Powershell script included. It is a modified version of the 
`user provising script available on the Box CLI Github <https://github.com/box/boxcli/blob/main/examples/User%20Creation%20%26%20Provisioning/Users_Create_Provision.ps1>`_.

The purpose of this script is to create Box users (add new hires to Box environment), create their personal folder and its "Archived" and "Active" subfolders, and apply access controls to these folders.

There are two input files and three output files.
	* Input
		* get-users.csv
		* Folder_Structure.json
	* Output
		* ArchiveFolderIDs.csv
		* MasterMap.csv
		* ActiveFolderIDs.csv

get-users.csv
-------------

This file is generated by the Get-AD-Users.ps1 script. It contains information pertaining to all 
users in Active Directory. This includes their ``firstName, lastName, username, email, manager, managerEmail``. The manager of the user is captured to share the O3 notes folder with and apply access controls (manager=editor, employee=viewer).

Below is a sample of what get-users.csv may look like. Note: users without manager do not have one assigned in AD.

.. code-block:: 
	:linenos:

	"firstName","lastName","email","username","managerEmail","manager"
	"PEI","Brandon","PEI.Brandon@truebeck.com","PEIBrandon",,
	"PEI","Kevin","PEI.Kevin@truebeck.com","PEIKevin",,
	"Eric","Schroeder","Eric.Schroeder@Truebeck.com","EricSchroeder","Mike.Elmore@Truebeck.com","Mike Elmore"
	"Azure","Test","Azure.Test@Truebeck.com","AzureTest",,
	"Erin","Test","Erin.Test@truebeck.com","ErinTest",,
	"Marcus","test","Marcus.test@truebeck.com","Marcustest",,
	"Deploy","Admin","Deploy.Admin@truebeck.com","DeployAdmin",,
	"Maintenance","Admin","Maintenance.Admin@truebeck.com","MaintenanceAdmin",,
	"Gareth","Oxendine","Gareth.Oxendine@Truebeck.com","GarethOxendine","Richard.Sealund@Truebeck.com","Richard Sealund"
	"Migration","Tool","Migration.Tool@truebeck.com","MigrationTool",,
	"Mike","Elmore","Mike.Elmore@Truebeck.com","MikeElmore","Matthew.McLean@Truebeck.com","Matthew McLean"
	"Jared","Putnam","Jared.Putnam@Truebeck.com","JaredPutnam","Richard.Sealund@Truebeck.com","Richard Sealund"
	"Al","Gomez","Albert.Gomez@truebeck.com","AlGomez","Richard.Sealund@Truebeck.com","Richard Sealund"
	"Crissi","Lanier","Crissi.Lanier@truebeck.com","CrissiLanier","Sean.Truesdale@truebeck.com","Sean Truesdale"
	"Zsofia","Gutvill","Zsofia.Gutvill@Truebeck.com","ZsofiaGutvill","Justin.Pebet@Truebeck.com","Justin Pebet"
	"Dennis","Richardson","Dennis.Richardson@Truebeck.com","DennisRichardson","Kathy.Reiner@truebeck.com","Kathy Reiner"
	"Jackie","Jensen","Jackie.Jensen@truebeck.com","JackieJensen","Rosanne.SmithKaya@truebeck.com","Rosanne Smith Kaya"
	"Shelley","Schmaltz","Shelley.Schmaltz@truebeck.com","ShelleySchmaltz","Dennis.Richardson@Truebeck.com","Dennis Richardson"
	"Amanda","Carson","Amanda.Carson@truebeck.com","AmandaCarson","Rosanne.SmithKaya@truebeck.com","Rosanne Smith Kaya"
	"Nicole","Cannon","Nicole.Cannon@Truebeck.com","NicoleCannon","Rosanne.SmithKaya@truebeck.com","Rosanne Smith Kaya"
	"Rosanne","Smith Kaya","Rosanne.SmithKaya@truebeck.com","RosanneSmithKaya","Kathy.Reiner@truebeck.com","Kathy Reiner"
	"Alex","Snyder","Alex.Snyder@truebeck.com","AlexSnyder","Justin.Porter@truebeck.com","Justin Porter"
	"Michael","Vachon","Michael.Vachon@Truebeck.com","MichaelVachon","Justin.Porter@truebeck.com","Justin Porter"
	"Rosemary","Newkirk","Rosemary.Newkirk@Truebeck.com","RosemaryNewkirk","Kathy.Reiner@truebeck.com","Kathy Reiner"
	"Andrea","Hernando","Andrea.Hernando@Truebeck.com","AndreaHernando","Justin.Porter@truebeck.com","Justin Porter"
	"Bryce","Haboian","Bryce.Haboian@Truebeck.com","BryceHaboian","Justin.Porter@truebeck.com","Justin Porter"

Folder_Structure.json
----------------------

Folder_Structure.json is a file used by Userprov.ps1 that details the subfolder structure inside the employee's personal O3 notes folder. In the case of this script, there are only "Active" and "Archived" subfolders, with no subfolders inside them at creation time.

.. code-block:: JSON
	:linenos:

	[
	  {
	    "name": "Archived",
	    "children": []
	  },

	  {
	    "name": "Active",
	    "children": []
	  }
	]


Further subfolders inside the above folders is possible following JSON syntax.

UserProv.ps1
------------

Below is the full Powershell script for provisioning users and their folders.

.. code-block:: Powershell
	:linenos:

	param ( 
	    # Set filepath of CSV of which the captured folder ID of each user's "Archived" folder will go
	    # This is used for the script that will create a new folder every month in each users "Archived" folder
	    # Reason for using a seperate CSV instead of MasterO3IDs.csv is because the `--bulk-file-path=` CLI flag expects a specific CSV format
	    [string]$ArchivedFolderIDsPath = "..\MonthlyArchiveCreate\Input\ArchiveFolderIDs.csv",
	    [string]$ActiveFolderIDsPath = "..\CopyTemplate\Input\ActiveFolderIDs.csv",

	    # This is a custom CSV file that will keep track of user, userfolderID, archivefolderID, activefolderID
	    # Will be used for mapping which folders files should be moved to in the MoveO3Notes.ps1 script
	    [string]$MasterMapFile = "..\MoveO3Notes\Input\MasterMap.csv",
	    
	    # Path to CSV where users to be added are stored.
	    [string]$EmployeeList = "..\Get-AD-Users\Output\get-users.csv",

	    # Personal Folder Structure: Set either path build off JSON or directly upload a local folder
	    [string]$FolderStructureJSONPath = ".\Input\Folder_Structure.json",
	    [string]$LocalUploadPath = "",
	    
	    # The string attached to the end of the folder created per user.
	    [string]$PersonalFolderSlug = "O3 Notes",

	    # ID of parent folder for created personal folders to be created in
	    [string]$PersonalFolderParentID = "218211112413"
	)

	# Idk what this is for
	Function Get-Script-Name() {
	    $filename = $MyInvocation.ScriptName | Split-Path -Leaf -ErrorAction SilentlyContinue
	    if ($filename -match ".") {
	        $filename = $filename.Substring(0, $filename.LastIndexOf("."))
	    }

	    return $filename
	}

	# I'm assuming this is for the log file that gets made when the script is run.
	Function Write-Log { param ([string]$message, [string]$errorMessage = $null, [Exception]$exception = $null, [string]$output = $false, [string]$color = "Green")

	    # Define log level - Can be "errors" or "all"
	    $logLevel = "all"

	    # Create logs directory if it doesn't exist
	    if (-not (Test-Path ".\logs")) {
	        New-Item -Path . -Name "logs" -ItemType 'directory' > $null
	    }

	    $dateTime = Get-Date

	    # Set log filename to the name of the script
	    $logFilename = Get-Script-Name
	    $debugErrorFile = ".\logs\" + $logFilename + "_errors.txt"
	    $debugAllFile = ".\logs\" + $logFilename + "_all.txt"

	    if ($exception -or $errorMessage) {
	        $severity = "ERROR"
	    } else {
	        $severity = "INFO"
	    }

	    if ($exception.Response) {
	        $result = $exception.Response.GetResponseStream()
	        $reader = New-Object System.IO.StreamReader($result)
	        $reader.BaseStream.Position = 0
	        $reader.DiscardBufferedData()
	        $responseBody = $reader.ReadToEnd();
	    }

	    $logMessage = ($severity + "`t")
	    $logMessage += ($dateTime)
	    $logMessage += ("`t" + $message + "`t")

	    if ($exception) {
	        $logMessage += ($exception.Message + "`t")
	    }

	    if ($errorMessage) {
	        $logMessage += ($errorMessage + "`t")
	    }

	    if ($responseBody) {
	        $logMessage += ("Box responded with: " + $responseBody + "`t")
	    }

	    if ($output -eq "true") {
	        Write-Host $message -ForegroundColor $color
	    }

	    if ($logLevel -eq "all") {
	        $logMessage | Add-Content $debugAllFile

	        if ($severity -eq "ERROR") {
	            $logMessage | Add-Content $debugErrorFile
	        }
	    } else {
	        if ($severity -eq "ERROR") {
	            $logMessage | Add-Content $debugErrorFile
	        }
	    }
	}

	# This class is used for setting/restoring analytics client header when running this script
	# Idk what this is for either, probably logging
	class AnalyticsClientManager {
	    [string]$TemporaryAnalyticsClientName
	    [string]$OriginalAnalyticsClientName
	    [bool]$IsOriginalAnalyticsClientEnabled

	    AnalyticsClientManager([string]$temporaryAnalyticsClientName) {
	        $this.TemporaryAnalyticsClientName = "box_sample_scripts $($temporaryAnalyticsClientName)"
	    }

	    [bool] IsAnalyticsClientSupported() {
	        return "$(box configure:settings --help)" -like "*--analytics-client-name*--json*"
	    }

	    [void] StoreOriginalSettings() {
	        $SettingsContent = "$(box configure:settings --json)" | ConvertFrom-Json

	        $this.OriginalAnalyticsClientName = $SettingsContent.AnalyticsClient.Name
	        if (!$this.OriginalAnalyticsClientName) {
	            $this.OriginalAnalyticsClientName = "cli"
	        }

	        if($SettingsContent.EnableanalyticsClient) {
	            $this.IsOriginalAnalyticsClientEnabled = $true
	        } else {
	            $this.IsOriginalAnalyticsClientEnabled = $false
	        }

	        Write-Log "Stored original analytics client settings, name: $($this.OriginalAnalyticsClientName), enabled: $($this.IsOriginalAnalyticsClientEnabled)." -output false
	    }

	    [void] RestoreOriginalSettings() {
	        if ($this.IsOriginalAnalyticsClientEnabled) {
	            $RestoreAnalyticsClientEnablementState = "--enable-analytics-client"
	        } else {
	            $RestoreAnalyticsClientEnablementState = "--no-enable-analytics-client"
	        }

	        "$(box configure:settings $RestoreAnalyticsClientEnablementState --analytics-client-name=$($this.OriginalAnalyticsClientName))"
	        Write-Log "Restored original analytics client settings, name: $($this.OriginalAnalyticsClientName), enabled: $($this.IsOriginalAnalyticsClientEnabled)." -output false
	    }

	    [void] SetScriptAnalyticsClient() {
	        if ($this.IsAnalyticsClientSupported()) {
	            $this.StoreOriginalSettings()

	            "$(box configure:settings --enable-analytics-client --analytics-client-name=$($this.TemporaryAnalyticsClientName))"
	            Write-Log "Set temporarily analytics client settings, name: $($this.TemporaryAnalyticsClientName), enabled: true." -output false
	        }
	    }

	    [void] UnsetScriptAnalyticsClients() {
	        if ($this.IsAnalyticsClientSupported()) {
	            $this.RestoreOriginalSettings()
	        }
	    }
	}

	##########################################################

	# First function to run.
	Function Start-Users-Provisoning-Creation-Script {
	    Write-Log "Starting User Creation & Personal Folder Provisioning script..." -output true

	    try {
	        # Import CSV with employees to make folders for
	        $Employees = Import-Csv $EmployeeList
	        Write-Log $Employees -output true
	    }
	    catch {
	        Write-Log "Failed to load mock employee data. Exits script." -errorMessage "Invalid input data." -output true -color Red
	        break
	    }

	    try {
	        #Create Managed Users and Provision Personal Folder
	        New-Provision-Managed-User
	        Write-Log "Users and Folders Created Successfully" -output true
	    }
	    catch {
	        Write-Log "Failed to create managed users." -errorMessage "Something went wrong" -output true -color Red
	    }

	}


	# Provision Box accounts for employee and their supervisor.
	Function New-Provision-Managed-User {
	    ForEach ($Employee in $Employees) {
	        Write-Log "Creating employee Managed User account with first name: $($Employee.firstName), last name: $($Employee.lastName), email: $($Employee.email)" -output True
	        # Create Managed User
	        try {
	            # This is the command for adding a user to box. Their username is the combination of fName+lName and their email is also attached. These are all defined in the input CSV file.
	            $CreatedManagedUserResp = (box users:create "$($Employee.firstName) $($Employee.lastName)" $Employee.email --json 2>&1)
	            $ManagedUserID = $CreatedManagedUserResp | ConvertFrom-Json | ForEach-Object { $_.id }
	            Write-Log "Created Managed user for email: $($Employee.email) where ID: $($ManagedUserID)." -output True
	        }
	        catch {
	            Write-Log "Failed to create Managed User for email: $($Employee.email). Skipping this user. See log for details." -errorMessage $CreatedManagedUserResp -output true -color Red
	            # Calls Create-Folders function even if user provisioning failed.
	            #Create-Folders
	        }
	        try {                   
	            # Provision supervisor
	            $CreatedSupervisorResp = (box users:create "$($Employee.manager)" $Employee.managerEmail --json 2>&1)
	            $SupervisorID = $CreatedSupervisorResp | ConvertFrom-Json | ForEach-Object {$_.id }
	            Write-Log "Created Supervisor $($Employee.manager) with ID: $SupervisorID for employee: $($Employee.username)" -output True
	            # Calls Create-Folders function if user provisioning succeeded.
	            Create-Folders
	        }
	        catch {
	            Write-Log "Failed to create Supervisor $($Employee.manager) for employee: $($Employee.username). Skipping this user. See log for details." -errorMessage $CreatedSupervisorResp -output true -color Red
	            # Calls Create-Folders function even if user provisioning failed.
	            Create-Folders
	        }
	    }
	}

	Function Create-Folders {
	        try {
	            # If a username is not supplied in the csv, the email address is used instead
	            if (-not $($Employee.username)){
	                $script:PersonalFolderName = $($Employee.email) + "'s " + $PersonalFolderSlug
	            } else {
	                $script:PersonalFolderName = $($Employee.username) + "'s " + $PersonalFolderSlug
	            }
	            Write-Log "Personal Folder Name: $PersonalFolderName " -output True
	            if ($FolderStructureJSONPath) {
	                # Create Folder Structure from JSON
	                New-Folder-Structure
	            }
	            elseif ($LocalUploadPath) {
	                # OR directly upload Folder structure to current user's root folder from local directory
	                $UploadedFoldersResp = box folders:upload $LocalUploadPath --parent-folder=$PersonalFolderParentID --folder-name=$script:PersonalFolderName --json 2>&1
	                $script:PersonalFolderID = $UploadedFoldersResp | ConvertFrom-Json | ForEach-Object { $_.id }
	            }
	            Write-Log "Uploaded local folder structure to $($Employee.username)'s O3 Notes folder with ID $($script:PersonalFolderID) where parent ID: $PersonalFolderParentID." -output true
	        }
	        catch {
	            Write-Log "Failed to upload local folder structure to parent folder with ID $PersonalFolderParentID." -errorMessage $UploadedFoldersResp -output true -color Red
	            
	        }

	        # Collaborate New Managed User to Folder Structure owned by current user
	        try {
	            $CollaboratedResp = box folders:collaborations:add $script:PersonalFolderID --role=viewer --user-id=$ManagedUserID --json 2>&1
	            $CollaboratedResp | ConvertFrom-Json | Out-Null
	            Write-Log "Collaborated Managed User $($Employee.firstName) $($Employee.lastName) to $($Employee.username) indicated folder for provisioning with ID: $script:PersonalFolderID." -output True
	        }
	        catch {
	            Write-Log "Failed to create collaboration for user $($Employee.firstName) $($Employee.lastName) with ID: $ManagedUserID, to folder ID: $script:PersonalFolderID. See log for details." -errorMessage $CollaboratedResp -output true -color Red
	        }
	        try {
	            # Added new lines below to give supervisor access
	            $SupervisorResp = box folders:collaborations:add $script:PersonalFolderID --role=editor --login=$Employee.managerEmail --json 2>&1
	            $SupervisorResp | ConvertFrom-Json | Out-Null
	            Write-Log "Supervisor User $($Employee.manager) to $($Employee.usernmae) indicated folder for provisioning with ID $script:PersonalFolderID" -output True
	        }
	        catch {
	            Write-Log "Failed to create collaboration for Supervisor $($Employee.manager) to folder ID: $script:PersonalFolderID. See log for details." -errorMessage $CollaboratedResp -output true -color Red
	            continue
	        }
	    }

	    # Create folder sturcture form JSON file
	Function New-Folder-Structure {
	    # Extract folder structure from json
	    Write-Log "Extracting folder structure" -output True
	    try {
	        $FolderStructure = Get-Content -Raw -Path $FolderStructureJSONPath | ConvertFrom-Json
	    }
	    catch {
	        Write-Log "Error reading '$FolderStructureJSONPath'. Exits script.". -errorMessage "Invalid input data."  -output True -color Red
	        break
	    }

	    # Create Personal Root folder
	    try {
	        $CreatedPersonalFolderResp = box folders:create "$PersonalFolderParentID" "$script:PersonalFolderName" --json 2>&1
	        $script:PersonalFolderID = $CreatedPersonalFolderResp | ConvertFrom-Json | ForEach-Object { $_.id }
	        Write-Log "Created a user owned '$PersonalFolderSlug' folder with id: $($script:PersonalFolderID)." -output True
	    }
	    catch {
	        Write-Log "Failed to create '$script:PersonalFolderName' folder. See log for details.". -errorMessage $CreatedPersonalFolderResp -output True -color Red
	        
	    }

	    # Create all folders structure from json file, where $PersonalFolderSlug is the parent
	    New-Subfolders-Recursively "$script:PersonalFolderID" "$script:PersonalFolderName" $FolderStructure
	}

	Function New-Subfolders-Recursively {
	    Param
	    (
	        [Parameter(Mandatory=$true, Position=0)]
	        [string] $ParentFolderId,
	        [Parameter(Mandatory=$true, Position=1)]
	        [string] $ParentFolderName,
	        [Parameter(Mandatory=$true, Position=2)]
	        [System.Object[]] $Children
	    )

	    ForEach ($child in $Children) {
	        try {
	            $CreatedChildFolderResp = box folders:create "$($ParentFolderId)" "$($child.name)" --fields="id,name" --json 2>&1
	            $CreatedChildFolder = $CreatedChildFolderResp | ConvertFrom-Json
	            Write-Log "Created subfolder '$($child.name)' with id: $($CreatedChildFolder.id) under '$ParentFolderName' (ID: $ParentFolderId) folder." -output True

	            # Provision supervisor
	            $CreatedSupervisorResp = (box users:create "$($Employee.manager)" $Employee.managerEmail --json 2>&1)
	            $SupervisorID = $CreatedSupervisorResp | ConvertFrom-Json | ForEach-Object {$_.id }
	            Write-Log "Created Supervisor $($Employee.supervisor) with ID: $SupervisorID for employee: $($Employee.username)" -output True
	            
	            if ($child.name -eq 'Active') {
	                $activeFolderId = $CreatedChildFolder.id
	            }
	            elseif ($child.name -eq 'Archived') {
	                $archiveFolderId = $CreatedChildFolder.id
	            }

	            if ($child.children -and $child.children.Length -gt 0) {
	                New-Subfolders-Recursively "$($CreatedChildFolder.id)" "$($child.name)" $($child.children)
	            }
	        }
	        catch {
	            Write-Log "Failed to create subfolder '$($child.name)' under '$ParentFolderName' (ID: $ParentFolderId) folder. See log for details." -errorMessage $CreatedChildFolderResp -output True -color Red
	            continue
	        }
	    }

	    # Output to MasterMap.csv
	    [PSCustomObject]@{
	        User = $ParentFolderName
	        ArchiveFolderID = $archiveFolderId
	        ActiveFolderID = $activeFolderId
	    } | Export-Csv -Path $MasterMapFile -NoTypeInformation -Append

	    # Output to ActiveFolderIDs.csv
	    if ($activeFolderId) {
	        [PSCustomObject]@{
	            ParentID = $ParentFolderId
	            ID = $activeFolderId
	            Name = ''
	        } | Export-Csv -Path $ActiveFolderIDsPath -NoTypeInformation -Append
	    }

	    # Output to ArchiveFolderIDs.csv
	    # Note: ParentID is being assigned the ID of the Archive folder, which would normally make more sense to be called "ID"
	    # The reason for using ParentID is because the MonthlyArchiveCreate.ps1 script needs the column name ParentID for the API call, as this is where the new subfolder will be placed.
	    if ($archiveFolderId) {
	        [PSCustomObject]@{
	            Name = ''
	            ParentID = $archiveFolderId
	        } | Export-Csv -Path $ArchivedFolderIDsPath -NoTypeInformation -Append
	    }
	}

	Start-Users-Provisoning-Creation-Script


As stated above, this script should output three different CSV files. MasterMap.csv, ArchiveFolderIDs.csv, and ActiveFolderIDs.csv.